# Kafka 장애 시 서로 다른 DB 간 데이터 무결성 보장 — Outbox 패턴 + Polling 발행

**project - SSG TBNTB**

---

## 도입 배경 및 성과

### 도입 배경

| 구분 | 내용 |
|------|------|
| **문제 상황** | 프로젝트 서비스 DB와 다른 서비스 DB(또는 구독 서비스) 간 이벤트 기반 동기화 시, Kafka 장애/지연 시 이벤트 유실 발생 |
| **기존 방식 한계** | 비즈니스 로직(DB 트랜잭션)과 Kafka 발행을 분리 처리 → DB 커밋 후 브로커 장애 시 발행 실패 시 재시도만 의존 → **누락 건 발생** (Beta 기간 중 4건 확인) |
| **무결성 이슈** | 한쪽 DB만 반영되고 이벤트는 전달되지 않아, 구독 서비스와 프로젝트 서비스 간 **데이터 불일치** 발생 |

### 성과

| 지표 | Before | After (Beta 1개월) |
|------|--------|---------------------|
| **이벤트 누락 건수** | 4건 | **0건** |
| **보장 방식** | DB 커밋 후 즉시 발행, 실패 시 유실 가능 | **Outbox 테이블 + Polling 발행**으로 At-least-once 보장 |

- 서로 다른 DB 간 **데이터 정합성** 확보
- Kafka 일시 장애/지연 시에도 **이벤트 누락 없이** 나중에 발행 가능

---

## 기존 설계 vs 해결 방법

### 기존 설계 (이벤트 유실 가능)

```
[비즈니스 로직] → DB Commit → Kafka 발행
                        ↓
                  발행 실패 시
                        ↓
              재시도만 수행 → 타임아웃/장애 시 유실
```

- DB 트랜잭션과 메시지 발행이 **서로 다른 트랜잭션 리소스**
- DB는 성공했는데 Kafka 발행이 실패하면 **영구 유실** 가능
- 재시도 로직을 넣어도 애플리케이션 재시작/장애 시 **누락** 발생 (Beta 기간 4건)

### 해결 방법: Outbox 패턴 + Polling 발행

```
[비즈니스 로직] → Outbox 테이블 INSERT (같은 DB 트랜잭션) → DB Commit
                        ↓
              Polling Worker가 주기적으로 Outbox 조회 (락 걸어서 가져오기)
                        ↓
              FOR UPDATE로 행 락 후 claim → 미발행 건만 선점
                        ↓
              Kafka 발행 → 성공 시 Outbox 상태 갱신(또는 삭제), 락 해제
```

- **Outbox 테이블**: 이벤트를 “DB와 동일 트랜잭션”으로 저장 → DB 커밋 = 이벤트 저장 보장
- **Polling 발행**: 별도 프로세스/스케줄러가 Outbox를 주기 조회 후 Kafka 발행 → **발행 실패 시 다음 폴링에서 재시도**
- Kafka 장애 시에는 발행만 실패하고, **Outbox에는 계속 남아 있어** 복구 후 0건 누락 가능

---

## 트러블 슈팅 요약

| 구분 | 내용 |
|------|------|
| **증상** | Beta 테스트 기간 중 이벤트 누락 4건 발생 (프로젝트/뉴스/CS 등 생성·수정·삭제 이벤트) |
| **원인** | DB 커밋 후 Kafka 동기 발행 실패 시 재시도 미흡 및 프로세스 종료 시 메모리 상 재시도 손실 |
| **해결** | Outbox 패턴으로 “DB 커밋 = 이벤트 영속화” 보장 + Polling으로 발행 실패 건 자동 재시도 |
| **결과** | 동일 Beta 환경 1개월 기준 **누락 4건 → 0건** |

---

## 설계 상세

### 1) Outbox 패턴 — 단일 DB 트랜잭션으로 무결성 확보

- 이벤트를 **Outbox 테이블**에 저장하는 작업을 **비즈니스 로직과 같은 DB 트랜잭션**에서 수행
- DB Commit이 성공하면 “이벤트가 반드시 한 번은 발행될 수 있는 상태”가 보장됨 (다른 DB와의 정합성 기준 데이터 확보)

### 2) Polling 발행 — 장애 내성

- **Polling Worker**: 주기적으로 Outbox에서 `status = PENDING`(또는 미발행) 건 조회
- 조회한 건을 Kafka로 발행 후, 성공 시 해당 건을 `PUBLISHED` 등으로 갱신(또는 삭제)
- 발행 실패 시 해당 건은 다음 폴링에서 **자동 재시도** → Kafka 장애가 해소되면 누락 없이 전달

### 3) 락 걸어서 조회 (Pessimistic Lock) — 중복 발행·경합 방지

- **목적**: Polling Worker가 여러 인스턴스로 떠 있을 때, **같은 Outbox 행을 여러 Worker가 동시에 가져가서 이중 발행되는 것**을 막기 위함
- **방식**: 조회 시 **행 단위 락** 사용
  - `SELECT ... FOR UPDATE` (JPA: `@Lock(LockModeType.PESSIMISTIC_WRITE)`)로 **가져올 때부터 해당 행을 락**
  - 다른 Worker는 해당 행을 락 대기하거나, `SKIP LOCKED` 사용 시 이미 락 걸린 행은 건너뛰고 다음 행만 조회 가능
- **Claim 처리**: 락 걸어서 가져온 건에 대해 `lockedBy`(Worker 인스턴스 ID), `lockedAt`(락 시각) 저장 후 상태를 `PROCESSING`으로 변경 → **이 행은 이 Worker가 담당**함을 DB에 기록
- **Stale Lock 복구**: 일정 시간(`processingTimeout`)이 지나도 완료되지 않은 건(`PROCESSING` + `lockedAt` 오래됨)은 **Worker 장애로 간주**하고, 조회 조건에 다시 넣어 다른 Worker가 가져가 재시도할 수 있게 함

정리하면, **“락 걸어서 가져오기”**로 한 건당 하나의 Worker만 처리하게 하고, 실패/타임아웃 시에는 다음 폴링에서 다시 claim 되도록 해서 누락 없이 발행하는 구조입니다.

### 4) 데이터 흐름 요약

| 단계 | 설명 |
|------|------|
| **생성/수정/삭제** | 도메인 이벤트 발생 시 Outbox 레코드 INSERT (같은 트랜잭션) |
| **Polling** | Worker가 N초마다 미발행 Outbox 조회 |
| **락 걸어서 조회** | `SELECT ... FOR UPDATE`(PESSIMISTIC_WRITE)로 행 락 후 claim(`lockedBy`, `lockedAt`, `PROCESSING`) → 여러 Worker가 동일 건 동시 처리 방지 |
| **발행** | Kafka로 메시지 전송 후 성공 시 Outbox 상태 갱신(SENT), 락 해제 |
| **재시도** | 실패 건은 다음 폴링까지 유지; stale lock은 다시 claim 대상 → 0건 누락 목표 달성 |

---

## 포트폴리오 한 줄 요약 (이력서/목차용)

**Kafka 장애 시 서로 다른 DB의 데이터 무결성 이슈 해결 — Outbox 패턴 + Polling 발행으로 누락 건수 4건 → 0건 (Beta 1개월)**

---

## 카드형 요약 (목차/슬라이드용)

**# Kafka 장애 시 서로 다른 DB 간 데이터 무결성 — Outbox + Polling 발행**  
**project - SSG TBNTB**

| | |
|---|---|
| **도입 배경** | 비즈니스 DB 커밋 후 Kafka 동기 발행 시, 브로커 장애/지연으로 이벤트 유실 발생 |
| | 서로 다른 DB 간 이벤트 기반 동기화 시 **정합성 깨짐** (Beta 기간 누락 4건) |
| **성과** | 이벤트 누락 **4건 → 0건** (Beta 1개월) |
| | Outbox + Polling으로 **At-least-once 발행** 및 재시도 자동화 |

**도입 배경 및 성과 · 트러블 슈팅 · 기존 설계 · 해결 방법**

- **기존 설계**: DB Commit → Kafka 즉시 발행 → 실패 시 재시도만 → 유실 가능
- **해결 방법**: Outbox 패턴(이벤트를 DB와 동일 트랜잭션으로 저장) + **락 걸어서 조회**(`FOR UPDATE` / PESSIMISTIC_WRITE)로 Polling Worker가 미발행 건만 선점 조회 후 Kafka 발행
- **락 조회**: 여러 Worker 인스턴스가 같은 행을 두 번 가져가지 않도록 **행 락 + claim**(`lockedBy`, `lockedAt`)으로 담당 Worker 고정, stale 시 재 claim 가능
- **트러블 슈팅**: Beta 기간 누락 4건 원인 분석 → Outbox 도입 후 동일 기간 0건으로 개선
